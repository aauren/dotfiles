#!/bin/bash
# Shows a list of branches for the first parameter (usually something like "refs" or "refs/heads")
# May be used with the following options as the second parameter (will only accept one of the following):
#  * -c: non-color - strips color from the output (useful for pipeing into other commands)
#  * -s: select - puts your into a mode to select a branch out of the output (automatically change to that branch)
#  * -v: verbose - after it finishes listing the branches it will show you the file change differences

format_git_branches () {
	RED=$(tput setaf 1)
	BLUE=$(tput setaf 4)
	BOLD_WHITE=$(tput bold; tput setaf 7)
	RESET=$(tput sgr0)
	BOLD_RED=$(tput bold; tput setaf 1)
	GREEN=$(tput setaf 2)
	local mystr=""
	local fmt="ref=%(refname:short); authordate=%(authordate:relative); commiterdate=%(committerdate); authorname=%(authorname); sha1=%(objectname);"
	local not_merged="$(git branch --no-merge)"
	echo -e "==========================================Branches================================================"
	local -i count=1
	local -a branches
	while read entry; do
		eval "${entry}"
		local nomerge=""
		local files_changed="$(git log "${ref}" --not --remotes=*/master --stat --pretty="format:" | grep '|')"
		branches+=("${ref}")
		# We'll use a hybrid of the above command and the output of git branch --no-merge to check for changes
		if [[ "${files_changed}" ]] || echo "${not_merged}" | grep -q -e "^[ ]*${ref}[ ]*$"; then
			nomerge="(*)"
		fi
		if [[ "${2}" && "${2}" == "-s" ]]; then
			printf "${BOLD_RED}[%3i]${RESET} " $((count++))
		fi
		if [[ "${2}" && "${2}" == "-c" ]]; then
			printf "%-30s" "${authordate}"
			printf "%-25s" "${authorname}"
			printf "%s%s\n" "${ref}" "${nomerge}"
		else
			printf "${BLUE}%-30s${RESET}" "${authordate}"
			printf "${RED}%-25s${RESET}" "${authorname}"
			printf "${BOLD_WHITE}%s${RESET}${BOLD_RED}%s${RESET}\n" "${ref}" "${nomerge}"
		fi
		if [[ "${2}" && "${2}" == "-v" && "${files_changed}" ]]; then
			mystr="${mystr}$(printf "%s%s%s:\n " "${RED}" "${ref}" "${RESET}")"
			while read file_lines; do
				file_part1="${file_lines%|*}"
				file_part2="${file_lines##*|}"
				file_part1="$(sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' <<< "${file_part1}")"
				file_part2="$(sed -r "s/(\+*)(-*)/${GREEN}\1${RESET}${RED}\2${RESET}/g" <<< "${file_part2}")"
				mystr="${mystr}$(printf "	%s%-60s%s -%s\n " "${BOLD_WHITE}" "${file_part1}" "${RESET}" "${file_part2}")"
			done <<< "${files_changed}"
		fi
	done <<<"$(git for-each-ref --tcl --sort=-committerdate --format="${fmt}" "${1}")"

	if [[ "${2}" && "${2}" == "-s" ]]; then
		printf "\n%sSelect Branch to Switch to (q to quit): %s" "${BOLD_WHITE}" "${RESET}"
		read -r uinput
		if [[ "${uinput}" == "q" ]]; then
			exit 0
		fi
		if ! [[ ${uinput} =~ ^[0-9]+$ && "$((uinput - 1))" -lt "${#branches[@]}" ]]; then
			echo "Could not validate input"
			exit 1
		fi
		echo "Switching to: ${branches[$((uinput - 1))]}"
		git co "${branches[$((uinput - 1))]}"
	fi

	if [[ "${2}" && "${2}" == "-v" ]]; then
		echo -e "\n========================================File Changes=============================================="
		echo -e "${mystr}"
	fi
}

format_git_branches "$@"

# vim: set noet sw=4 ts=4
