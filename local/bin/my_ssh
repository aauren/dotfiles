#!/bin/bash

# Here so that you're returned to a shell
trap "{ exec /bin/zsh; }" SIGINT

# Here to consolidate SSH files
cat ~/.ssh/config.d/* >~/.ssh/config

# shellcheck source=/dev/null
source "${HOME}/bin/helpers.sh"

OPTIND=1
app_name="$(basename "${0}")"
app_signature="${app_name} [OPTION] IP_ADDRESS|DNS_NAME"
usage="usage: ${app_signature}
An SSH wrapper script that makes sure that the host is available
and listening on the desired port first, and optionally sets up
the requested host with my specified environment. It will also keep
attempting to reconnect to the host.

Options:
  -h,-?\t\tdisplay this help text and exit
  -e\t\tdon't setup environment on remote machine
  -m\t\tuse Mosh to connect to host"

parse_args ()
{
	while getopts "h?em" opt; do
		case "${opt}" in
			h|\?) echo -e "${usage}"; exit 0;;
			e) nosetup=true;;
			m) mosh=true;;
		esac
	done

	shift $((OPTIND-1))
	if [[ -z ${1} ]]; then
		echo "You must specify an IP address or host to connect to: ${app_signature}" >> /dev/stderr
		echo "HINT: use -h for more usage information" >> /dev/stderr
		exit 1
	fi
	remote_host="${1}"
}


main ()
{
	local -i RETVAL=0
	local HOST=${remote_host:-not_set}

	[[ "${HOST}" == "not_set" ]] && exit 1

	# Separate host string into parts
	if [[ "${HOST}" == *@* ]]; then
		hostname="${HOST##*@}"
		# shellcheck disable=SC2034
		username="${HOST%@*}"
	else
		hostname="${HOST}"
	fi


	# Check to see if an SSH port is explicitely defined in ssh config files
	my_ssh_port="$(parse_ssh_config | grep "${hostname}" |cut -d',' -f 3)"
	unaliased_ssh_host="$(resolve_host_from_ssh_config "${hostname}")"
	export my_ssh_port unaliased_ssh_host

	if [[ "PROXYJUMP" == "${unaliased_ssh_host}" ]]; then
		echo "ProxyJump detected for host, skipping host setup and healthchecks..."
	else
		echo "Checking Host Status..."
		is_node_up "${unaliased_ssh_host}" "${my_ssh_port:-22}"

		if [[ -e "${HOME}/.ssh/no_setup_hosts" ]] && grep -q -f "${HOME}/.ssh/no_setup_hosts" <<<"${unaliased_ssh_host}"; then
			echo "Detected No Remote Env Setup Host (~/.ssh/no_setup_hosts)..."
			nosetup=true
		fi

		if [[ -z ${nosetup} && ("${HOST}" != *@* || ${HOST%@*} == $(whoami)) && "root" != $(whoami) ]]; then
			if [[ -n "${mosh}" ]]; then
				echo "Setting Up Remove Env with mosh..."
				setup_remote_env "${HOST}" "mosh"
			else
				echo "Setting Up Remove Env..."
				setup_remote_env "${HOST}"
			fi
		fi
	fi
	# Check mosh status
	if [[ -n "${mosh}" ]]; then
		if ! command -v mosh-client >/dev/null 2>&1; then
			echo >&2 "Mosh was chosen, but not in path, falling back to ssh"
			unset mosh
		elif [[ ! -e "${HOME}/bin/mosh-server" ]]; then
			echo >&2 "Mosh server does not appear to be in path, and we can't guarantee it's on the other side, falling back to ssh"
			unset mosh
		fi
	fi
	# Command here will run SSH as the literally SSH and not loop back into this wrapper script
	if [[ -n "${mosh}" && -z "${nosetup}" ]]; then
		mosh -A --server='~/bin/mosh-server' "${HOST}"
	else
		command ssh -Aq "${HOST}" || RETVAL=${?}
	fi

	printf "\nSSH Exit Code: %d\n\n" ${RETVAL}
	printf "\n%s\n\n" "$(date)"

	return ${RETVAL}
}

parse_args "$@"

time while : ; do
	main "${1}" && break
	sleep 15
done

exec /bin/zsh
