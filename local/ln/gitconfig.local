[alias]
	l = log --pretty=colored
	cm = commit -m
	dc = diff --cached
	unstg = reset HEAD
	dt = difftool
	dtc = difftool --cached
	lg = log --color --graph --pretty=format:'%Cred%<(8)%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --decorate
	rc = rebase --continue
	can = commit --amend --no-edit
	ca = commit --amend -v
	# An alternative to git pull: git upfrom <remote> <branch-name>
	upfrom = "!f() { git fetch $1 --prune; git merge --ff-only $1/$2 || git rebase --preserve-merges $1/$2; }; f"
	sh = show HEAD
	cp = cherry-pick
	r9 = rebase -i HEAD~9
	r8 = rebase -i HEAD~8
	r7 = rebase -i HEAD~7
	r6 = rebase -i HEAD~6
	r5 = rebase -i HEAD~5
	r4 = rebase -i HEAD~4
	r3 = rebase -i HEAD~3
	r2 = rebase -i HEAD~2
	r1 = rebase -i HEAD~1
	cl = clone
	# Fetch branch from origin
	fob = fetch origin
	br = branch --all
	# Show all branches sorted, etc
	abrs = for-each-ref --sort=-committerdate --format=\"%(color:blue)%(authordate:relative)\t%(color:red)%(authorname)\t%(color:white)%(color:bold)%(refname:short)\" refs
	lbrs = for-each-ref --sort=-committerdate --format=\"%(color:blue)%(authordate:relative)\t%(color:red)%(authorname)\t%(color:white)%(color:bold)%(refname:short)\" refs/heads
	po = push origin
	pof = push origin --force-with-lease
	pot = push origin --tags
	# Finds the upstream tracking branch, if it contains a remote, fetch the remote first, then attempt to merge, failing over into a rebase operation if that fails
	up = "!f() { \
		upstream_br="$(git rev-parse --abbrev-ref "$(git rev-parse --abbrev-ref HEAD)@{upstream}")"; \
		if [[ ${upstream_br} == *"/"* ]]; then \
			echo "=== fetching ${upstream_br%%/*}..."; \
			git fetch ${upstream_br%%/*} --prune; \
		fi; \
		echo "=== merging/rebasing on top of ${upstream_br}..."; \
		git merge --ff-only "${upstream_br}" || git rebase --preserve-merges "${upstream_br}"; \
	}; f"
	# Like the above, except that this one is DANGEROUS because it will rebase accepting all of their branch's changes in the event of a conflict
	fup = "!f() { \
		upstream_br="$(git rev-parse --abbrev-ref "$(git rev-parse --abbrev-ref HEAD)@{upstream}")"; \
		if [[ ${upstream_br} == *"/"* ]]; then \
			echo "=== fetching ${upstream_br%%/*}..."; \
			git fetch ${upstream_br%%/*} --prune; \
		fi; \
		echo "=== merging/rebasing on top of ${upstream_br}..."; \
		git merge --ff-only "${upstream_br}" || git rebase -s recursive -X ours "${upstream_br}"; \
	}; f"
	# Updates this branch and it's tracking branch (assuming that the tracking branch isn't a remote) using the "up" alias above
	tup = "!f() { \
		upstream_br="$(git rev-parse --abbrev-ref "$(git rev-parse --abbrev-ref HEAD)@{upstream}")"; \
		if [[ ! ${upstream_br} == *"/"* ]]; then \
			echo "=== Updating from: ${upstream_br}"; \
			git co "${upstream_br}"; \
			git up; \
			echo "=== Changing back to update current branch..."; \
			git co -; \
			git up; \
		else \
			echo "Tracking branch is a remote, not running"; \
		fi; \
	}; f"
	sl = "!f() { git stash list | cat; }; f"
	sp = "!f() { if [[ -z $1 ]]; then git stash pop; else git stash pop $(git stash list | grep -m 1 $1 | cut -d':' -f1); fi; }; f"
	sa = "!f() { if [[ -z $1 ]]; then git stash apply; else git stash apply $(git stash list | grep -m 1 $1 | cut -d':' -f1); fi; }; f"
	ss = "!f() { git stash save --keep-index $1; }; f"
	ssp = "!f() { git stash save --patch --keep-index $1; }; f"
	edit = !$EDITOR $(git status --short | awk '$1 ~ /^M|A|U/ {print $2}' )
[user]
	name = Aaron U'Ren
[core]
	editor = vim
[diff]
	tool = vimdiff
[difftool]
	prompt = false
[include]
	path = ~/.gitconfig.user.local
[rerere]
	enabled = true
[branch]
	autoSetupMerge = always

# vim: set noet ts=2 sw=2
