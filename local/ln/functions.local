# Displays the tmux var valued passed as the first parameter
# shellcheck disable=SC2086
# shellcheck disable=SC2046
tmux_info() {
	local tmux_var="${1}"
	tmux display -pt "${TMUX_PANE:?}" "#{${tmux_var}}"
}

# Automatically creates a git commit message based on the files that are staged and prints it on the line
gitcm () {
	((sleep 0.1 && tmux send-keys -t "$(tmux_info session_name):$(tmux_info window_name).$(tmux_info pane_index)" "$(echo "git cm \"$(git diff --name-only --cached | grep -o '[^/]*$' | sed ':a;N;$!ba;s/\n/ \& /g'): ")") &)
}

# Loads a bunch of color variables into ZSH so that you can reference them as a variable by their name
load_colors () {
	autoload colors
	for COLOR in RED GREEN YELLOW BLUE MAGENTA CYAN BLACK WHITE; do
		eval $COLOR='$fg_no_bold[${(L)COLOR}]'
		eval BOLD_$COLOR='$fg_bold[${(L)COLOR}]'
		eval BG_$COLOR='$bg[${(L)COLOR}]'
	done
	eval RESET='$reset_color'
}

# Traverse up to the specified directory
uptil () {
	current_dir="$(pwd)"
	while [[ "$(basename "${current_dir}")" != *"${1}"* ]]; do current_dir="$(dirname "${current_dir}")"; done
	# shellcheck disable=SC2164
	pushd "${current_dir}"
}

# Find a file with a pattern in name
ff() { find . -type f -iname '*'$*'*' -ls ; }

# Find a file with pattern $1 in name and Execute $2 on it
fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ; }

# Ping the specified host and include the date in the output
pingd() { ping $1 | while read -r pong; do echo "$(date): $pong"; done }

# Show broadcast routes for exabgp
exabgp_show_routes() {
	local socket_path="${1:-/run/exabgp/exabgp.socket}"
	if [[ -S "${socket_path}" ]]; then
		echo "show routes" | socat -  "UNIX-CONNECT:${socket_path}"
		return 0
	else
		echo "exabgp socket does not exist: ${socket_path}"
		return 1
	fi
}

# Prompts the user for a selection from a list of line delimitted options
prompt_for_selection() {
	local it uinput option param count bg_color
	local -a results
	load_colors

	count=1
	while read -r it; do
		bg_color=""
		if [[ $(( count % 2 )) -eq 1 ]]; then
			bg_color="${BG_BLACK}"
		fi
		printf "%s[%s%3i%s%s] - %s%s%s\\n" "${bg_color}" "${BOLD_RED}" "$((count++))" "${RESET}" "${bg_color}" "${BLUE}" "${it}" "${RESET}" 1>&2
		results+=( "${it}" )
	done <<<"${1}"
	printf "\\n%sChoose option (q to quit): %s" "${BOLD_WHITE}" "${RESET}" 1>&2
	read -r uinput

	for param in ${uinput}; do
		if [[ "${param}" == "q" ]]; then
			return 1
		fi
		if [[ "${param}" =~ ^[[:digit:]]+$ ]]; then
			option="${results[${param}]}"
			#echo "chose: ${option}" 1>&2
		else
			echo "Option selected was not recognized, quitting" 1>&2
			return 2
		fi
	done
	echo "${option}"
}

# Elastic Search Functions {{{
# Finds the field data usage for a given environment
elastic_fielddata() {
	curl "http://${1}:9200/_nodes/stats/indices/fielddata?fields=*" 2>/dev/null \
		| jq -r '.nodes[] | .name + " " + (.indices.fielddata.memory_size_in_bytes | tostring) + " " + (.indices.fielddata.evictions | tostring)' \
		| grep esd \
		| awk -F' ' '{ printf "%-20s %0.2f GB (evictions: %s)\n", $1, $2/1024/1024/1024, $3 }' \
		| sort -V
}
# }}}

# Kubernetes Query Functions {{{
# kpp (kubernetes pick pod) - Allows you to pick a pod and a namespace dynamically from a list
# Example: kpp
kpp() {
	local kube_results selection

	kube_results="$(kubectl get pods --all-namespaces -o wide)"
	selection="$(prompt_for_selection "${kube_results}")"
	K8S_NS="$(awk '{print $1}' <<<"${selection}")"
	K8S_POD="$(awk '{print $2}' <<<"${selection}")"
}

kpr() {
	unset K8S_NS K8S_POD
}

k8s_set_ns_option() {
	if [[ -n "${K8S_NS}" ]]; then
		printf -- "-n %s" "${K8S_NS}"
	else
		printf -- "--all-namespaces"
	fi
}

k8sctl() {
	local action="${1}" object="${2}"
	shift

	if [[ "${action}" == "logs" ]]; then
		kubectl $(k8s_set_ns_option) logs ${K8S_POD} "${@}"
		return
	fi
	shift
	case "${object}" in
		pods)
			kubectl "${action}" "${object}" ${K8S_POD} $(k8s_set_ns_option) "${@}"
			;;
		namespaces)
			kubectl "${action}" "${object}" ${K8S_NS} "${@}"
			;;
		clusterroles|clusterrolebindings|nodes)
			kubectl "${action}" "${object}" "${@}"
			;;
		*)
			kubectl "${action}" "${object}" $(k8s_set_ns_option) "${@}"
			;;
	esac
}

kgp() { k8sctl get pods "${@}"; }
kdp() { k8sctl describe pods "${@}"; }
kgdp() { k8sctl get deployments "${@}"; }
kddp() { k8sctl describe deployments "${@}"; }
kgds() { k8sctl get daemonsets "${@}"; }
kdds() { k8sctl describe daemonsets "${@}"; }
kgrs() { k8sctl get replicasets "${@}"; }
kdrs() { k8sctl describe replicasets "${@}"; }
kgss() { k8sctl get statefulsets "${@}"; }
kdss() { k8sctl describe statefulsets "${@}"; }
kgs() { k8sctl get services "${@}"; }
kds() { k8sctl describe services "${@}"; }
kgcr() { k8sctl get clusterroles "${@}"; }
kdcr() { k8sctl describe clusterroles "${@}"; }
kgcrb() { k8sctl get clusterrolebindings "${@}"; }
kdcrb() { k8sctl describe clusterrolebindings "${@}"; }
kgsa() { k8sctl get serviceaccounts "${@}"; }
kdsa() { k8sctl describe serviceaccounts "${@}"; }
kgl() { k8sctl logs "${@}"; }
kglc() { k8sctl get pods -o json | jq -r '.status | .initContainerStatuses, .containerStatuses | select(. != null) | .name'; }
kgcm() { k8sctl get configmaps "${@}"; }
kdcm() { k8sctl describe configmaps "${@}"; }
kge() { k8sctl get endpoints "${@}"; }
kde() { k8sctl describe endpoints "${@}"; }
kgns() { k8sctl get namespaces "${@}"; }
kdns() { k8sctl describe namespaces "${@}"; }
kgn() { k8sctl get nodes "${@}"; }
kdn() { k8sctl describe nodes "${@}"; }
kgr() { k8sctl get roles "${@}"; }
kdr() { k8sctl describe roles "${@}"; }
kgrb() { k8sctl get rolebindings "${@}"; }
kdrb() { k8sctl describe rolebindings "${@}"; }
# }}}

# vim: set noet ts=4 sw=4 syntax=sh ft=sh fdm=marker
