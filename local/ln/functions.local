# Displays the tmux var valued passed as the first parameter
tmux_info() {
	local tmux_var="${1}"
	tmux display -pt "${TMUX_PANE:?}" "#{${tmux_var}}"
}

# Automatically creates a git commit message based on the files that are staged and prints it on the line
gitcm () {
	((sleep 0.1 && tmux send-keys -t "$(tmux_info session_name):$(tmux_info window_name).$(tmux_info pane_index)" "$(echo "git cm \"$(git diff --name-only --cached | grep -o '[^/]*$' | sed ':a;N;$!ba;s/\n/ \& /g'): ")") &)
}

# Loads a bunch of color variables into ZSH so that you can reference them as a variable by their name
load_colors () {
	autoload colors
	for COLOR in RED GREEN YELLOW BLUE MAGENTA CYAN BLACK WHITE; do
		eval $COLOR='$fg_no_bold[${(L)COLOR}]'
		eval BOLD_$COLOR='$fg_bold[${(L)COLOR}]'
		eval BG_$COLOR='$bg[${(L)COLOR}]'
	done
	eval RESET='$reset_color'
}

# Traverse up to the specified directory
uptil () {
	current_dir="$(pwd)"
	while [[ "$(basename "${current_dir}")" != *"${1}"* ]]; do current_dir="$(dirname "${current_dir}")"; done
	pushd "${current_dir}"
}

# Find a file with a pattern in name
ff() { find . -type f -iname '*'$*'*' -ls ; }

# Find a file with pattern $1 in name and Execute $2 on it
fe() { find . -type f -iname '*'$1'*' -exec "${2:-file}" {} \;  ; }

# Ping the specified host and include the date in the output
pingd() { ping $1 | while read pong; do echo "$(date): $pong"; done }

# Show broadcast routes for exabgp
exabgp_show_routes() {
	local socket_path="${1:-/run/exabgp/exabgp.socket}"
	if [[ -S "${socket_path}" ]]; then
		echo "show routes" | socat -  "UNIX-CONNECT:${socket_path}"
		return 0
	else
		echo "exabgp socket does not exist: ${socket_path}"
		return 1
	fi
}

# Prompts the user for a selection from a list of line delimitted options
prompt_for_selection() {
	local it uinput option param count bg_color
	local -a results
	load_colors

	count=1
	while read -r it; do
		bg_color=""
		if [[ $(( ${count} % 2 )) -eq 1 ]]; then
			bg_color="${BG_BLACK}"
		fi
		printf "%s[%s%3i%s%s] - %s%s%s\n" "${bg_color}" "${BOLD_RED}" "$((count++))" "${RESET}" "${bg_color}" "${BLUE}" "${it}" "${RESET}" 1>&2
		results+=( "${it}" )
	done <<<"${1}"
	printf "\n%sChoose option (q to quit): %s" "${BOLD_WHITE}" "${RESET}" 1>&2
	read -r uinput

	for param in ${uinput}; do
		if [[ "${param}" == "q" ]]; then
			return 1
		fi
		if [[ "${param}" =~ ^[[:digit:]]+$ ]]; then
			option="${results[${param}]}"
			#echo "chose: ${option}" 1>&2
		else
			echo "Option selected was not recognized, quitting" 1>&2
			return 2
		fi
	done
	echo "${option}"
}

# Elastic Search Functions {{{
# Finds the field data usage for a given environment
elastic_fielddata() {
	curl "http://${1}:9200/_nodes/stats/indices/fielddata?fields=*" 2>/dev/null \
		| jq -r '.nodes[] | .name + " " + (.indices.fielddata.memory_size_in_bytes | tostring) + " " + (.indices.fielddata.evictions | tostring)' \
		| grep esd \
		| awk -F' ' '{ printf "%-20s %0.2f GB (evictions: %s)\n", $1, $2/1024/1024/1024, $3 }' \
		| sort -V
}
# }}}

# vim: set noet ts=4 sw=4 syntax=sh ft=sh fdm=marker
