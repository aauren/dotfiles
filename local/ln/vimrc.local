" Tips and Tricks
"
" Search and Replace:
"   1. Change the currently searched for item by typing cgnReplacement<Esc>, repeat with .

" Change text width to 120 which is a more sensible default
set textwidth=120
" Allows you to open a new buffer when there are unwritten changes to the current buffer
set hidden
" Set search to always highlight
set hlsearch
" Set the sign column so that the text doesn't shift each time CoC makes a diagnostic (I haven't found this all that
" helpful, but leaving it here since they recommend it so that I can come back to it)
"set signcolumn=yes
" Having longer uptimetime for CoC (default is 4000 ms = 4 seconds) leads to noticable delays and poor experienc
set updatetime=300

" This tells VIM where to look for generated ctags, in this case the .git directory is used because everything in that
" directory is automatically un-indexed
set tags^=./.git/tags;

" Set the default preview popup window size to a little bigger than its default so that the contents are more readable
set previewheight=30

" General autocommands that don't have to do with filetypes
augroup general
  " A work around for the fact that the above setting isn't actually respected by VIM, when you enter a buffer it checks
  " to see if the buffer is a preview window and if so, it expands it to the setting above.
  autocmd BufEnter ?* call PreviewHeightWorkAround()
augroup END

" If set, would cause preview-popup to be used instead of preview-window. Preview-popups are a new feature of VIM 8.2
" that creates a special window that can be stacked on a z-axis. However, it cannot be interracted with which carries
" with it a bunch of limitations.
"set previewpopup=height:40,width:100

" Various mappings for CTRL+P {{{

" Search git directories faster by using silver searcher or ripgrep or ignoring git directories
let g:ctrlp_use_caching = 0

" When selecting multiple files, don't open any as splits (0), but instead open them as buffers (i)
let g:ctrlp_open_multiple_files = '0i'

" r chooses the nearest ancestor that contains a .git, .hg, .svn, or .bzr directory
" a the directory of the current file if the working directory of CTRLP isn't a direct ancestor of the file
let g:ctrlp_working_path_mode = 'ra'

" Set the list of ctrlp extensions that we want to use
let g:ctrlp_extensions = ['line']

" The following checks to make sure that the silver-searcher binary is available, if it is, use it for searching
" everywhere, not just in Ctrp-P (that's what grepprg and grepformat do)
if executable('rg')
    set grepprg=rg\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m

    let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""'
elseif executable('ag')
    set grepprg=ag\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m

    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
else
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
  " Commenting this out for now because it will conflict with my other set of prompt matchings above
  "let g:ctrlp_prompt_mappings = {
  "  \ 'AcceptSelection("e")': ['<space>', '<cr>', '<2-LeftMouse>'],
  "  \ }
endif
" }}}

" Plugin Configurations - Various items for NerdTree, scratch buffers, airline, etc {{{

" Settings for NerdTree
augroup nerdtree
  " Ensure NerdTree autocloses if it's the last window open and exit vim
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
  " Highlight currently open buffer in NERDTree if NERDTree is open
  autocmd BufEnter * call SyncTree()
augroup END

" If the any of the scratch buffers (opened in the functions below) is the last window open, then close it and exit vim
augroup scratchbuffer
  autocmd bufenter * if (winnr("$") == 1 && exists("b:scratch")) | q | endif
augroup END

" Settings for Airline
" Show buffers as well as tabs
let g:airline#extensions#tabline#enabled = 1
" Allow powerline fonts that pretty print the bars at the top and bottom
let g:airline_powerline_fonts = 1
" Enable/Disable showing a summary of changed hunks under source control
let g:airline#extensions#hunks#enabled=1
" Show branches in Airline
let g:airline#extensions#branch#enabled=1
" Airline theme that matches well with solarized theme (this now happens automatically because of base16)
"let g:airline_theme="gruvbox"
" Show vim-obsession session tracking status in airline (when tracking display [TRK SESS] in lower right)
" In order to restore, use either vim -S or :source
let g:airline_section_z = airline#section#create(['%{ObsessionStatus(''[TRK SESS]'', '''')}', 'windowswap', '%3p%% ', 'linenr', ':%3v '])
" Needed so that we can see the current function (from the vista plugin) in airline on the bottom-right of the screen
augroup myairline
  autocmd VimEnter * call timer_start(2000, { tid -> execute('if exists(":Vista") && get(g:, "coc_start_at_startup", 1) | call vista#RunForNearestMethodOrFunction() | endif')})
augroup END

" Gitgutter settings
" Set SignColumn highight group to same as LineNr so that it doesn't turn grey
highlight! link SignColumn LineNr
" if git doesn't exist on the system, set gitgutter_enabled to 0 so that we don't try to load it and get an error
if !executable("git")
  let g:gitgutter_enabled=0
endif

" Settings for jedi-vim
" Don't start auto-completing on . (if you still need auto-completion use Ctrl-Space)
let g:jedi#popup_on_dot = 0

" Settings for Vista (LSP / CoC Symbol Outliner)
" Change default executive from ctags to coc (LSP) backed implementation
let g:vista_default_executive = 'coc'
" Disable the use of fancy symbols for the tag tree since we don't have them or need them
let g:vista#renderer#enable_icon = 0
" Set the vista to the topleft instead of the bottom right
let g:vista_sidebar_position = 'vertical topleft'
" Set the vista width to give a bit more space
let g:vista_sidebar_width = 50
" Close the vista window after a jump
let g:vista_close_on_jump=1
augroup vista
  " Auto-close visa outline if it is the last buffer open and vim is exiting
  autocmd bufenter * if (winnr("$") == 1 && exists("b:current_syntax")) && b:current_syntax == 'vista' | q | endif
augroup END


" }}}

" File type based autocmd's (e.g. python width 120, tab expansion for python, sh, etc, upconf and json settings {{{

augroup filetypes
  " Setting a different indentation for Python so that we get more than 80 characters in a column
  autocmd Filetype python set textwidth=120

  " Set different indent styles for different file types
  autocmd Filetype python setlocal et ts=4 sw=4 sts=4 nowrap nofoldenable
  autocmd Filetype sh setlocal ts=4 sw=4 sts=4 noexpandtab nowrap
  autocmd Filetype ebuild setlocal ts=4 sw=4 sts=4 noexpandtab nowrap
  autocmd Filetype java setlocal ts=4 sw=4 sts=4
  autocmd Filetype yaml setlocal ts=2 sw=2 sts=2 et
  autocmd Filetype go setlocal ts=4 sw=4 sts=4 noet
  autocmd Filetype markdown setlocal tw=120

  " Set file type to upconf template when it has deploy/config in the path
  autocmd BufRead,BufNewFile */deploy/config/* set filetype=upconf-template

  " Treat .input files the same as JSON
  autocmd BufRead,BufNewFile *.input set filetype=json

  " Treat .confd and .initd files the same as shell
  autocmd BufRead,BufNewFile *.confd set filetype=sh
  autocmd BufRead,BufNewFile *.initd set filetype=sh

  " Treat .tf files as terraform
  autocmd BufRead,BufNewFile *.tf set filetype=terraform

  " Manually set the filetype to gitcommit when buffer is called COMMIT_EDITMSG so that in case the diff contains a
  " modline it won't do something crazy with the syntax recognition
  autocmd BufEnter COMMIT_EDITMSG set filetype=gitcommit
augroup END

" }}}

" Various whitespace highlighting, autocmds for EOL highlights {{{
" Setup highlights to be used in autocmds and the functions that autocmds call
highlight ExtraWhitespace ctermbg=red guibg=red
highlight WhiteSpaceBol guifg=darkgrey ctermfg=darkgrey
" These two numbers are the same term color that my solarized terminal uses and can be used to effectively hide
" characters by setting the foreground and background to the same as my terminal
highlight WhiteSpaceMol ctermfg=8 ctermbg=8
" Setup tab indents to be a milder form of grey
highlight SpecialKey ctermfg=14 ctermbg=8
" Set the highlighting for CoC's popup windows
highlight CocFloating ctermfg=32 cterm=bold
highlight CocErrorFloat ctermfg=red cterm=bold

" Used in the ToggleLeadingSpace function below, used to indicate that when we open files we don't want them to show
" leading spaces initially
let g:show_leading_space = 0
let g:show_sign_column = 0

augroup whitespace
  " Upon buffer read or new buffer setup our listchars settings
  autocmd BufRead,BufNewFile * call SetupLCS()

  " This can be used just in case future colorscheme commands attempt to clear our manually added highlights, this adds
  " them back directly after any colorscheme changes. In practice I haven't found this necessary, commentting for now
  "autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red
  "autocmd ColorScheme * highlight WhiteSpaceBol guifg=darkgrey ctermfg=darkgrey
  "autocmd ColorScheme * highlight WhiteSpaceMol ctermfg=8 ctermbg=8

  " This shows extra whitespace EXCEPT when we're typing at the end of the line, therefore, we only want this match
  " loaded when we are in insert mode. We'll load this one, and delete the match below when we enter insert mode. We
  " have to add silent! to the beginning of this call because on the first InsertEnter after opening a file 104 won't
  " exist and 103 will already exist. See call matchadd("ExtraWhitespace"... below.
  " matchadd parameters: matchadd(<highlight_name>, <pattern>, <priority_greater_num_means_more_prio>, <id>)
  autocmd InsertEnter * silent! call matchadd("ExtraWhitespace", '\s\+\%#\@<!$', 10, 103)
  " IDs 100 and 101 are created below in section: My functions (toggle solarized background, etc)
  autocmd insertEnter * silent! call matchdelete(104)

  " This always shows whitespace at the end of the line, we use this pattern when we leave insert mode. When we leave
  " insert we'll load this one and delete the match above. No silent is needed as everything is already setup the way it
  " should (unlike above where it might be the first insert of the session) so no errors are thrown.
  autocmd InsertLeave * silent! call matchadd("ExtraWhitespace", '\s\+$', 10, 104)
  " IDs 100 and 101 are created below in section: My functions (toggle solarized background, etc)
  autocmd InsertLeave * silent! call matchdelete(103)
augroup END

" Makes it so that you never scroll into the quickfix buffer when using buffernext/bufferprevious commands
augroup qfix
  autocmd!
  autocmd FileType qf set nobuflisted
augroup END

" When we first open VIM we need to have a rule that maches EOL whitespace (before the InsertEnter and InsertLeave
" autocmds above are called) so that we can see whitespace before messing with insertmode.
call matchadd("ExtraWhitespace", '\s\+$', 10, 104)

" }}}

" Python pep8 and pymode configurations {{{
" Add ignores for annoying pep8 guidelines
" E501: Lines should be less than 80 characters
" E265: There should be a space between # and comments
let g:pep8_ignore="E501,E265"
let g:pymode_lint_ignore="E501,E265"

" }}}

" CoC specific configuration {{{

" CoC requires npm installed, when we are remote we will likely not have it installed and we don't want to see warnings,
" so disable it on machines without node available.
if !executable('npm')
  let g:coc_start_at_startup = 0
endif

if get(g:, 'coc_start_at_startup', 1)
  " Set autocompeltion to only happen on trigger character
  call coc#config('suggest', {
        \ "autoTrigger": "trigger"
        \})
endif

" augroup for CoC related items
augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" }}}

" ALE specific configuration {{{

" Enable Airline symbols
let g:airline#extensions#ale#enabled = 1
" Have ALE use better symbols for marking errors and warnings
let g:ale_sign_error = "✗"
let g:ale_sign_warning = "⚠"
" Open the ALE loclist window when there are errors
let g:ale_open_list = 1
" Don't lint when the buffer opens to reduce spame when we're just viewing files
let g:ale_lint_on_enter = 0

" Enable various linters that are otherwise disabled. See:
" https://github.com/dense-analysis/ale/blob/master/supported-tools.md
let g:ale_linters = {'go': ['golangci-lint','gopls','govet','golint']}

" Use the following link for a lot of language specific information:
" https://github.com/dense-analysis/ale/tree/master/doc

" Python options see: https://github.com/dense-analysis/ale/blob/master/doc/ale-python.txt for more options
" Set flake8 to set line length to 120 characters
let g:ale_python_flake8_options = '--max-line-length 120 --extend-ignore E722'

let g:ale_go_golangci_lint_options = ''

" Buffer customizations for ALE
augroup ALELintingGroup
  autocmd!
  " Ignore certain errors in ebuilds
  autocmd BufEnter *.ebuild let b:ale_sh_shellcheck_exclusions = 'SC2034'
  " Don't auto-open the list on ebuilds so that ALE is less invasive
  autocmd BufEnter *.ebuild let b:ale_open_list = 0
augroup END

" Autoclose loclist window when the buffer is closed
augroup CloseLoclistWindowGroup
  autocmd!
  autocmd QuitPre * if empty(&buftype) | lclose | endif
augroup END

" }}}

" Use multiple presses of v to expand and ctrl-v to shrink regions {{{
" Actual mappings down in the binding section, see: expand_region_
" Default settings. (NOTE: Remove comments in dictionary before sourcing)
let g:expand_region_text_objects = {
    \ 'iw'  :0,
    \ 'iW'  :0,
    \ 'i"'  :0,
    \ '^o$' :0,
    \ '0o$' :0,
    \ 'i''' :0,
    \ 'i]'  :1,
    \ 'ib'  :1,
    \ 'iB'  :1,
    \ 'il'  :0,
    \ 'ip'  :0,
    \ 'ie'  :0,
    \ }
" }}}

" Persistent undo settings (allows you to get undo back even after closing a file) {{{

if has("persistent_undo")
  let myUndoDir = expand('$HOME/.vim/undodir/')
  call system('mkdir ' . myUndoDir)
  let &undodir = myUndoDir
  set undofile
endif

" }}}

" My functions (toggle solarized background, etc) {{{

" !help! Custom Functions [[[

" !help! RestoreRegister: Prevent replacing copy buffer on visual paste (preserve previous copy item on visual paste)
" hint: makes it so that vp doesn't replace paste buffer
function! RestoreRegister()
  let @" = s:restore_reg
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction

" !help! MyTogBG: Toggles the background and colorscheme on and off (this helps screens with bad color or copy/paste)
function! MyTogBG()
  redir => s:curr_background
    silent execute "colorscheme"
  redir END
  let s:curr_background = substitute(s:curr_background, '\n', '', '')
  let &background = ( &background == "dark"? "light" : "dark" )
  if s:curr_background =~? ".*default.*"
    exe "colorscheme " . s:background
  else
    exe "colorscheme default"
  endif
  let s:background = s:curr_background
endfunction

" !help! MyTogTW: Toggles the textwidth ruler on the right (useful when you don't want autowrap or copy/paste operations)
function! MyTogTW()
  if &tw
    let s:txtwid = &textwidth
    let s:wrapmarg  = &wrapmargin
    let &textwidth  = 0
    let &wrapmargin = 0
    set colorcolumn=0
  else
    let &textwidth = s:txtwid
    let &wrapmargin = s:wrapmarg
    set colorcolumn=+1
  endif
endfunction

" !help! ToggleCopyable: Toggles all of the above, plus some extra to allow for select based copy/paste operations)
function! ToggleCopyable()
  call MyTogBG()
  set list!
  set number!
  call MyTogTW()
  if exists(":ALEToggle")
    exe "ALEToggle"
  endif
  if exists(":GitGutterToggle")
    exe "GitGutterToggle"
  endif
  if g:show_sign_column == 0
    set signcolumn=no
    let g:show_sign_column = 1
  else
    set signcolumn=yes
    let g:show_sign_column = 0
  endif
  " We need to re-link the GitGutter SignColumn to LineNr so it doesn't turn grey
  highlight! link SignColumn LineNr
endfunction

" !help! MyGrepCommand: Automatically opening the quickfix pane (handles MiniBufExplorer)
function! MyGrepCommand(...)
  " This actually runs rg/ag because of the greprg setting above
  exe "silent grep " . join(a:000, " ")
  if exists(":MBEClose")
    exe "MBEClose"
  endif
  copen
  redraw!
  if exists(":MBEOpen")
    exe "MBEOpen"
  endif
endfunction

" !help! MyErrorsCommand: Shows and hides errors and focuses the error list (handles MiniBufExplorer)
function! MyErrorsCommand()
  if exists(":MBEClose")
    exe "MBEClose"
  endif
  if exists(":Errors")
    exe "Errors"
  endif
  exe "redraw!"
  if exists(":MBEOpen")
    exe "MBEOpen"
  endif
  if ! empty(getloclist(0))
    exe "wincmd j"
  endif
endfunction

" !help! ExportKeys: Export current key bindings to a vertical split scratch buffer
function! ExportKeys()
  redir! => l:mappings
    silent exe "map"
  redir END
  botright vnew
  silent exe "put =l:mappings"
  setlocal buftype=nofile bufhidden=wipe noswapfile nobuflisted nowrap
  let b:scratch = 1
  1
  " This could be d 4 but then VIM stops to tell me that 4 lines were removed and X number of lines were added
  d
  d
  d
  d
endfunction

" !help! VSplitCurrentBuffer: Split the current buffer and rotate main screen to previous buffer
function! VSplitCurrentBuffer()
  vs
  wincmd h
  bp
endfunction

" !help! SplitCurrentBuffer: Split the current buffer and rotate main screen to previous buffer
function! SplitCurrentBuffer()
  sp
  wincmd h
  bp
endfunction

" !help! s:RunShellCommand: Function to paste the output of a command inside a scratch buffer
function! s:RunShellCommand(cmdline)
  let isfirst = 1
  let words = []
  for word in split(a:cmdline)
    if isfirst
      let isfirst = 0  " don't change first word (shell command)
    else
      if word[0] =~ '\v[%#<]'
        let word = expand(word)
      endif
      let word = shellescape(word, 1)
    endif
    call add(words, word)
  endfor
  let expanded_cmdline = join(words)
  botright vnew
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  silent execute '$read !'. expanded_cmdline
  let b:scratch = 1
  1
  d
endfunction

" !help! ShowVimCustomizations: Show VIM customizations
function! ShowVimCustomizations()
  call s:RunShellCommand('extract_vim_help')
  set modeline | doautocmd BufRead
endfunction

" This is really just a helper function to the ToggleList option below
function! s:GetBufferList()
  redir =>buflist
  silent! ls!
  redir END
  return buflist
endfunction

" !help! ToggleList: Toggles either the quickfix or location list windows if they are open
function! ToggleList(bufname, pfx)
  let buflist = s:GetBufferList()
  for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
    if bufwinnr(bufnum) != -1
      exec(a:pfx.'close')
      return
    endif
  endfor
  if a:pfx == 'l' && len(getloclist(0)) == 0
      echohl ErrorMsg
      echo "Location List is Empty."
      return
  endif
  let winnr = winnr()
  exec(a:pfx.'open')
  if winnr() != winnr
    wincmd p
  endif
endfunction

" !help! DoPrettyXML: formats the current XML document in a prettified way
function! DoPrettyXML()
  " save the filetype so we can restore it later
  let l:origft = &ft
  set ft=
  " delete the xml header if it exists. This will
  " permit us to surround the document with fake tags
  " without creating invalid xml.
  1s/<?xml .*?>//e
  " insert fake tags around the entire document.
  " This will permit us to pretty-format excerpts of
  " XML that may contain multiple top-level elements.
  0put ='<PrettyXML>'
  $put ='</PrettyXML>'
  silent %!xmllint --format -
  " xmllint will insert an <?xml?> header. it's easy enough to delete
  " if you don't want it.
  " delete the fake tags
  2d
  $d
  " restore the 'normal' indentation, which is one extra level
  " too deep due to the extra tags we wrapped around the document.
  silent %<
  " back to home
  1
  " restore the filetype
  exe "set ft=" . l:origft
endfunction
command! PrettyXML call DoPrettyXML()

" !help! SetupLCS: Sets up initial (normal) listchars in VIM. It is used on start by autocmd above.
function! SetupLCS()
  if has("patch-8.1-0759")
    set listchars=tab:\|->
  else
    set listchars=tab:->
  endif
  set listchars+=nbsp:·,trail:·
  set listchars+=extends:>,precedes:<
endfunction

" !help! ToggleLeadingSpaces: Disables all leading spaces to make it easier to copy/paste from window
function! ToggleLeadingSpaces(...)
  " A one should be passed as the first argument to this function if you don't want to toggle the functionality, but
  " just want it to re-run existing settings instead.
  if a:0 != 1
    if g:show_leading_space == 0
      let g:show_leading_space = 1
    else
      let g:show_leading_space = 0
    endif
  endif
  if g:show_leading_space == 1 " Show leading spaces
    call SetupLCS()
    " Show the space character as a ·
    set listchars+=space:·

    " IDs 103 and 104 along with highlight definitions are described above in the section titled:
    " Various whitespace highlighting, autocmds for EOL highlights

    " This one matches all whitespace and applies the highlight WhiteSpaceMol hides the space listchar above ^^ by
    " making it's foreground and background the same color as my solarized terminal
    call matchadd("WhiteSpaceMol", " ", -5, 100)

    " This one overrides the above match (by giving it a higher priority -4 > -5) and applies the highlight
    " WhiteSpaceBol which shows the space listchar above ^^ by applying a proper foreground and background
    call matchadd("WhiteSpaceBol", '^ \+', -4, 101)

  else " Hide leading spaces

    call SetupLCS()

    " Delete our above matches so that space characters in any position aren't hidden or improperly displayed
    call matchdelete(100)
    call matchdelete(101)
  endif
endfunction
command! ToggleLeadingSpaces call ToggleLeadingSpaces()

" !help! CreateCtagsInGit: Creates a file in .git/tags with all of the tags from the current project in it
function! CreateCtagsInGit()
  if isdirectory("./.git")
    if &ft == 'go'
      silent! !gotags -silent -tag-relative -sort -f ./.git/tags **/*.go
    else
      silent! !ctags -f ./.git/tags &>/dev/null
    endif
    redraw!
  else
    echohl ErrorMsg
    echo "Cannot find .git directory so cannot create ctags"
  endif
endfunction
command! CreateCtags call CreateCtagsInGit()

" !help! Z: cd to recent / frequent directories
function! Z(...)
  let cmd = 'fasd -d -e printf'
  for arg in a:000
    let cmd = cmd . ' ' . arg
  endfor
  let path = system(cmd)
  if isdirectory(path)
    echo path
    exec 'cd ' . path
  endif
endfunction

" !help! V: edit file based on frequent list
function! V(...)
  let cmd = 'fasd -f -e printf'
  for arg in a:000
    let cmd = cmd . ' ' . arg
  endfor
  let path = system(cmd)
  if filereadable(path)
    "echo path
    exe "edit" . path
  endif
endfunction

" !help! Marks: display all marks and prompts you for a mark to go to
function! Marks()
    marks
    echo('Mark: ')

    " getchar() - prompts user for a single character and returns the chars
    " ascii representation
    " nr2char() - converts ASCII `NUMBER TO CHAR'

    let s:mark = nr2char(getchar())
    " remove the `press any key prompt'
    redraw

    " build a string which uses the `normal' command plus the var holding the
    " mark - then eval it.
    execute "normal! '" . s:mark
endfunction

" !help! Showdocumentation: display CoC documentation in a preview window
function! ShowDocumentation(...)
  " A one should be passed as the first argument to this function if you want to show doc results in a preview pane no
  " matter what
  if a:0 == 1
    let l:previewPane = 1
  else
    let l:previewPane = 0
  endif
  if CocAction('hasProvider', 'hover')
    let l:docArr = join(CocAction('getHover'))
    echo 'words in doc: ' . len(l:docArr)
    if len(l:docArr) > 2000 || l:previewPane == 1
      call CocActionAsync('doHover', 'preview')
    else
      call CocActionAsync('doHover')
    endif
  endif
endfunction

" !help! CheckBackspace: Needed for CoC checks what the previous character is to see if this should be a regular tab
" character, or if it should be a completion command. If the previous character was a space, it triggers non-completion
" and puts a tab instead.
" See: https://github.com/neoclide/coc.nvim
function! CheckBackspace() abort
  " Get the index of the previous character - col('.') gets the byte index of the column of the current cursor position
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Check if NERDTree is open or active
function! IsNERDTreeOpen()
  return exists("t:NERDTreeBufName") && (bufwinnr(t:NERDTreeBufName) != -1)
endfunction

" Call NERDTreeFind iff NERDTree is active, current window contains a modifiable
" file, and we're not in vimdiff
function! SyncTree()
  if &modifiable && IsNERDTreeOpen() && strlen(expand('%')) > 0 && !&diff
    NERDTreeFind
    wincmd p
  endif
endfunction

" Because of the above function, we need to modify NERDTreeToggle just a bit
function! ToggleNerdTree()
  set eventignore=BufEnter
  NERDTreeToggle
  set eventignore=
endfunction

" Because the previewheight settings isn't actually respected by VIM
function! PreviewHeightWorkAround()
  if &previewwindow
    exec 'setlocal winheight='.&previewheight
  endif
endfun

" This is needed for where we remap our tab key, to ensure that CoC exists before we try to call the functions. We use
" :CocInfo as a litmus test of whether or not CoC is installed on this system.
function! CocTabExpand()
  if exists(":CocInfo")
    return coc#pum#visible() ? coc#pum#next(1):
    \ CheckBackspace() ? "\<Tab>" :
    \ coc#refresh()
  else
    return "\<Tab>"
  endif
endfunction

" This is needed for where we remap our return key, to ensure that CoC exists before we try to call the functions. We
" use :CocInfo as a litmus test of whether or not CoC is installed on this system.
function! CocCRExpand() abort
  if exists(":CocInfo")
    return coc#pum#visible() ? coc#pum#confirm(): "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
  else
    return "\<CR>"
  endif
endfunction


" !help! ]]]
" }}}

" Custom commands {{{

" !help! Custom Commands [[[
" !help! ToggleBG: Calls function MyTogBG() to toggle the background color
command! ToggleBG :call MyTogBG()
" !help! toggleTextWidth: Calls function MyTogTW() to toggle the text width limitations
command! ToggleTextWidth :call MyTogTW()
" !help! ToggleCopyable: Calls function ToggleCopyable() to toggle copy mode of text
command! ToggleCopyable :call ToggleCopyable()
" !help! AG: Calls function MyGrepCommand to use AG to grep through stuff
command! -nargs=* AG :call MyGrepCommand(<f-args>)
" !help! AG: Calls function MyGrepCommand to use RG to grep through stuff
command! -nargs=* RG :call MyGrepCommand(<f-args>)
" !help! Shell: Calls s:RunShellCommand to show command output in a vertical split
command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
" !help! Z: cd to recent / frequent directories
command! -nargs=* Z :call Z(<f-args>)
" !help! V: edit file based on frequent list
command! -nargs=* V :call V(<f-args>)
" !help! ]]]

" }}}

" Remapping keys using combos and leaders {{{

" Reminder of what stuff means:
" (remap is the default, noremap means that the binding is not recursive, meaning that whatever the value of the binding
" is, it takes that value regardless of other surrounding bindings)
"
" :map  - Normal, Visual, Select, Operator-pending
" :nmap - Normal
" :vmap - Visual and Select
" :smap - Select
" :xmap - Visual
" :omap - Operator-pending
" :map! - Insert and Command-line
" :imap - Insert
" :lmap - Insert, Command-line, Lang-Arg
" :cmap - Command-line

" !help! Key Bindings [[[

" !help! Command Bindings [[[

" !help!  w!!: Allow saving of files as sudo when we forgot to start vim using sudo
cmap w!! w !sudo tee > /dev/null %
" !helm! <Ctrl-g><CR>: Activate search as quick jump with <Ctrl-g><CR> key combo is used at the end of a search pattern
cmap <C-g><CR> <Plug>(SearchAsQuickJump)

" !help! ]]]

" !help! Visual Bindings [[[
" !help! v: Expand selection with multiple presses of v
vmap v <Plug>(expand_region_expand)
" !help! <CTRL-v>: Shrink Selection with multiple presses of CTRL-v
vmap <C-v> <Plug>(expand_region_shrink)
" !help! p: Change visual paste to use the Repl() function described in "Prevent replacing copy buffer..."
vmap <silent> <expr> p <sid>Repl()
" !help! y: Jump to the end of the text you just pasted
vnoremap <silent> y y`]
" !help! p: Jump to the end of the text you just pasted
vnoremap <silent> p p`]
" !help! <leader-d>: Delete item to the blackhole register (meaning don't overwrite the current buffer)
vnoremap <leader>d "_d
" For more info on the below see: http://vim.wikia.com/wiki/Copy_or_change_search_hit
" !help! Creates a simple search text object identified as "s" so that you can manipulate search hits (do things like yank, change, etc)
vnoremap <silent> s //e<C-r>=&selection=='exclusive'?'+1':''<CR><CR>
      \:<C-u>call histdel('search',-1)<Bar>let @/=histget('search',-1)<CR>gv
" !help! ]]]

" !help! Normal Bindings [[[
" !help! p: Jump to the end of the text you just pasted
nnoremap <silent> p p`]
" !help! <leader-dd>: Delete line to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <leader>dd "_dd
" !help! <leader-d>: Delete item to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <leader>d "_d
" !help! <leader-x>: Delete character to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <leader>x "_x
" !help! <leader b>: Open/close buffer list and prompt for selection
nnoremap <leader>b :ls<CR>:b<Space>
" !help! gb: Open/close buffer list and prompt for selection
nnoremap gb :ls<CR>:b<Space>
" !help! <CTRL-b>: Open ctrlp in tag mode for all files under the current working directory
nnoremap <C-b> :CtrlPMRU<CR>
" !help! <ALT-p>: Open ctrlp in using a new root
nnoremap <Esc>p :CtrlPCurWD<CR>
" !help! <leader-s>: Toggle showing/hiding leading spaces
nnoremap <leader>s :ToggleLeadingSpaces<CR>
" We no longer use ctags
"nnoremap <leader>B :CreateCtags<CR>
" Set tab merge alias to vertically split current tab and the tab to the right (or barring that, to the left)
" To put them back to tabs afterward, type CTRL+w, SHIFT+t
"nnoremap <C-t> :TagbarToggle<CR>
" !help! <leader-g>: Pre-forms Z change of path command
nnoremap <leader>g :Z 

" !help! ]]]

" !help! Insert Bindings [[[
" !help! jj: When hit in quick succession same as escape
imap jj <Esc>
" !help! JJ: When hit in quick succession same as escape
imap JJ <Esc>
" !help! ]]]

" !help! Operator Pending Bindings [[[
" For more information see: http://vim.wikia.com/wiki/Copy_or_change_search_hit
" !help! Operator pending mode is entered with "c" or "y" pressing v after executes visual mode and then s after it which is defined above
omap v :normal vs<CR>
" !help! ]]]

" !help! Map Bindings [[[
" !help! gV: Quickly select the text you just pasted
noremap gV `[v`]

" Add control based navigation to insert mode
" !help! <CTRL-g>: Move right one word in any mode
map <C-G> <C-Right>
map! <C-G> <C-Right>
" !help! <CTRL-f>: Move left one word in any mode
map <C-F> <C-Left>
map! <C-F> <C-Left>
" !help! <CTRL-j>: Move to the beginning of the line in any mode
map <C-J> ^
map! <C-J> <Home>
" !help! <CTRL-k>: Move to the end of the line in any mode
map <C-K> $
map! <C-K> <End>

" !help! <CTRL-n>: Go to the previous error location
map <C-n> :lprev<CR>
" !help! <CTRL-m>:Go to the next error location
map <C-m> :lnext<CR>

" !help! ': Calls custom Marks() function which allows user to see a list of marks before choosing a mark to go to
nnoremap ' :call Marks()<CR>

" Set tab merge alias to vertically split current tab and the tab to the right (or barring that, to the left)
" To put them back to tabs afterward, type CTRL+w, SHIFT+t
" removing in favor of taglist, leaving this here for now for history: map <C-t> <esc>:Tabmerge right<CR>

" CoC Bindings {{{
" !help! CoC (Conquer of Completion) Autocomplete and GoTo Mappings [[[
" Use tab for trigger completion with characters ahead and navigate.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB> CocTabExpand()
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
inoremap <silent><expr> <CR> CocCRExpand()

" Use <c-space> to trigger completion.
if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif


" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list
" !help! [g: Go to previous diagnostic
nmap <silent> [g <Plug>(coc-diagnostic-prev)
" !help! g[: Go to next diagnostic
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" GoTo code navigation
" !help! gd: Go to definition
nmap <silent> gd <Plug>(coc-definition)
" !help! gy: Go to type definition
nmap <silent> gy <Plug>(coc-type-definition)
" !help! gi: Go to implementation
nmap <silent> gi <Plug>(coc-implementation)
" !help! gr: Go to references
nmap <silent> gr <Plug>(coc-references)

" Show documentation in correct window depending on length
" !help! gp: Show documentation in length sensitive window
nmap <silent> gp :call ShowDocumentation()<CR>
" Show documentation in preview window
" !help! gP: Show documentation in preview window
nmap <silent> gP :call ShowDocumentation(1)<CR>

" Format selected text using CoC
" Add the mapping for visual select mode
" !help! <leader f>: format selected text (in visual mode)
xmap <leader>f <Plug>(coc-format-selected)
" Add the map for normal mode
" !help! <leader f>: format the file (in normal mode)
nmap <leader>f <Plug>(coc-format)

" Process a symbol rename
" !help! <leader rn>: rename the symbol under the cursor
nmap <leader>rn <Plug>(coc-rename)

" !help! ]]]
" }}}

" Set ALE shortcuts
" !help! ALE Linter Mappings [[[
" !help! <CTRL-k> k: Go to previous error
nmap <silent> <C-k>k <Plug>(ale_previous_wrap)
" !help! <CTRL-k> j: Go to next error
nmap <silent> <C-k>j <Plug>(ale_next_wrap)
" !help! <leader a>: Disable ALE
map <leader>a :ALEToggle<CR>
" !help! ]]]

" GitGutter Mappings
" !help! GitGutter Mappings [[[
" !help! ]c Go to next git hunk change
" !help! [c Go to previous git hunk change
" !help! ]]]

" Remap next and previous tab to Ctrl-PgDn and Ctrl-PgUp
" !help! <ALT-h>: Go to previous window
map <Esc>h <C-w>W
" !help! <ALT-l>: Go to next window
map <Esc>l <C-w>w
" !help! <ALT-j>: Go to previous buffer
map <Esc>j :bp<CR>
" !help! <ALT-k>: Go to next buffer
map <Esc>k :bn<CR>
" This does the same as the above <Esc>j and <Esc>k, but it is needed for OSX which sends characters instead
map ê :bp<CR>
map ë :bn<CR>

" !help! <leader p>: Toggle paste mode
map <leader>p :set paste!<CR>
" !help! <leader po>: Paste a partial yank on the line below
map <leader>po :pu<CR>
" !help! <leader pO>: Paste a partial yank on the line above
map <leader>pO :pu!<CR>
" !help! <leader y>: leader mapping to allow for copying from vim
map <leader>y :ToggleCopyable<CR>
" !help! <leader w>: Toggle text width on and off
map <leader>w :ToggleTextWidth<CR>
" !help! <leader l>: Open/Close the location list window (for things like pylint)
map <silent> <leader>l :call ToggleList("Location List", 'l')<CR>
" !help! <leader q>: Open/Close the quickfix window
map <silent> <leader>q :call ToggleList("Quickfix List", 'c')<CR>
" !help! <leader li>: Toggle showing certain whitespace characters
map <leader>li :set list!<CR>
" !help! <leader n>: Toggle show number
map <leader>n :set number!<CR>
" !help! <leader r>: Toggle relative line numbering
map <leader>r :set relativenumber!<CR>
" !help! <leader e>: Shows linting errors location window in a way that won't affect MiniBufExplorer
map <leader>e :call MyErrorsCommand()<CR>
" !help! <leader csd>: Reset the color scheme to the default (in cases with unconfigured terminals)
map <leader>csd :ToggleBG<CR>
" !help! <leader t>: Map nerdtree to leader+t
map <leader>t :call ToggleNerdTree()<CR>
" !help! <leader k>: Search current buffer for item under the current cursor
map <leader>k :RG <cword> %<CR>
" !help! <leader K>: Search the entire working directory for the item under the cursor
map <leader>K :RG <cword><CR>
" !help! <leader u>: Toggle undo tree and then focus the original vim pane again with leader-u
map <leader>u :UndotreeToggle<cr><C-w>l
" !help! <leader S>: Force a Synstastic check
map <leader>S :ALELint<CR>
" !help! <leader j>: Re-format a JSON document, this allows you to write compactly, but read "prettily"
map <leader>j :%!python -m json.tool<CR>
" !help! <leader X>: Re-format an XML document in a way that is easy to read but may not be syntatically the same
map <leader>X :call DoPrettyXML()<CR>
" !help! <leader map>: Dump all of the current keys bindings/mappings to a file and open it
map <leader>map :call ExportKeys()<CR>
" !help! <leader vs>: Split the current buffer to the other vertical
map <leader>vs :call VSplitCurrentBuffer()<CR>
" !help! <leader hs>: Split the current buffer to the other horizontal
map <leader>hs :call SplitCurrentBuffer()<CR>
" !help! <leader vc>: Open my vim customizations to a vertical split
map <leader>vc :call ShowVimCustomizations()<CR>
" Because we can sometimes have buffers like nerdtree or outline, we want to close the current buffer without
" auto-focusing those other windows and causing them to take up all of our screen, for something that is just supposed
" to sit on the left. So this changes to the previous buffer, and then closes the last opened buffer.
" !help! <leader z>: Close current buffer
map <leader>z :bp<CR>:bd #<CR>
" !help! <leader Z>: Close current window (use instead of :q)
map <leader>Z :close<CR>
" !help! <leader T>: Begin tracking the current vim session with the obsession plugin
map <leader>T :Obsess ~/.vim/session/%:t<CR>
" !help! <leader o>: Show vista symbol outline for the given file
map <leader>o :Vista!!<CR>
" !help! ]]]

" !help! QuickFix Window Bindings [[[
" !help! <Enter>: Open location in a new buffer
" let g:qfenter_open_map = ['<CR>', '<2-LeftMouse>']
" !help! <CTRL-v>: Open location in a vertical split
let g:qfenter_vopen_map = ['<C-v>']
" !help! <CTRL-Enter> or <CTRL-s> or <CTRL-x>: Open in a horizontal split
let g:qfenter_hopen_map = ['<C-CR>', '<C-s>', '<C-x>']
" !help! <CTRL-t>: Open in a new tab
let g:qfenter_topen_map = ['<C-t>']
" !help! ]]]

" }}}

" Change Color Scheme (if bundles is available) {{{
if filereadable(expand("~/.vimrc.bundles"))
  " On remote systems that run tmux not setting the background seems to cause issues with the margins
  " appearing to be a yellow/white color, but on non-remote systems running tmux setting a background
  " just causes poor performance. With this hopefully we only set it when necessary.
  "if $TERM == "screen-256color" && !empty($SSH_TTY)
    set background=dark
  "endif
  " Tells solarized to use the default terminal background instead of it's own (speeds up terminal behavior)
  let g:solarized_termtrans=1
  "Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.
  "If you're using tmux version 2.2 or later, you can remove the outermost $TMUX check and use tmux's 24-bit color support
  "(see < http://sunaku.github.io/tmux-24bit-color.html#usage > for more information.)
  if (empty($TMUX))
    if (has("nvim"))
      "For Neovim 0.1.3 and 0.1.4 < https://github.com/neovim/neovim/pull/2198 >
      let $NVIM_TUI_ENABLE_TRUE_COLOR=1
    endif
    "For Neovim > 0.1.5 and Vim > patch 7.4.1799 < https://github.com/vim/vim/commit/61be73bb0f965a895bfb064ea3e55476ac175162 >
    "Based on Vim patch 7.4.1770 (`guicolors` option) < https://github.com/vim/vim/commit/8a633e3427b47286869aa4b96f2bfc1fe65b25cd >
    " < https://github.com/neovim/neovim/wiki/Following-HEAD#20160511 >
    if (has("termguicolors")) && empty($SSH_TTY)
      set termguicolors
    endif
  endif
  let base16colorspace=256
  colorscheme base16-gruvbox-dark-hard
  "highlight NonText guibg=#060606
  "highlight Folded  guibg=#0A0A0A guifg=#9090D0
endif
" }}}

" vim: fdm=marker ts=2 et
