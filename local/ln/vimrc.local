" Tips and Tricks
"
" Search and Replace:
"   1. Change the currently searched for item by typing cgnReplacement<Esc>, repeat with .

" Change text width to 120 which is a more sensible default
set textwidth=120

" Change color scheme to dark solarized if bundles is available {{{
if filereadable(expand("~/.vimrc.bundles"))
  set background=dark
  colorscheme solarized
  "highlight NonText guibg=#060606
  "highlight Folded  guibg=#0A0A0A guifg=#9090D0
endif
" }}}

" Various mappings for CTRL+P {{{

" Search git directories faster by using silver searcher or ignoring git directories
let g:ctrlp_use_caching = 0
if executable('ag')
    set grepprg=ag\ --vimgrep\ $*
    let g:ackprg = 'ag --vimgrep'
    set grepformat=%f:%l:%c:%m

    let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
else
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files . -co --exclude-standard', 'find %s -type f']
  " Commenting this out for now because it will conflict with my other set of prompt matchings above
  "let g:ctrlp_prompt_mappings = {
  "  \ 'AcceptSelection("e")': ['<space>', '<cr>', '<2-LeftMouse>'],
  "  \ }
endif
" }}}

" Various items for NerdTree, and other plugins (Like close NerdTree when all other buffers are closed) {{{

augroup nerdtree
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
augroup END

" If the any of the scratch buffers (opened in the functions below) is the last window open, then close it and exit vim
augroup scratchbuffer
  autocmd bufenter * if (winnr("$") == 1 && exists("b:scratch")) | q | endif
augroup END

let g:airline#extensions#tabline#enabled = 1
let g:airline_powerline_fonts = 1
let g:airline#extensions#hunks#enabled=1
let g:airline#extensions#branch#enabled=1
let g:airline_theme="ubaryd"

" }}}

" File type based autocmd's (e.g. python width 120, tab expansion for python, sh, etc, upconf and json settings {{{
augroup filetypes
  " Setting a different indentation for Python so that we get more than 80 characters in a column
  autocmd Filetype python set textwidth=120

  " Set different indent styles for different file types
  autocmd Filetype python setlocal et ts=4 sw=4 sts=4 nowrap nofoldenable
  autocmd Filetype sh setlocal ts=4 sw=4 sts=4 noexpandtab nowrap
  autocmd Filetype ebuild setlocal ts=4 sw=4 sts=4 noexpandtab nowrap

  " Set file type to upconf template when it has deploy/config in the path
  autocmd BufRead,BufNewFile */deploy/config/* set filetype=upconf-template
  autocmd Filetype json let b:indentLine_ConcealOptionSet = 1
augroup END

" }}}

" Various whitespace highlighting, autocmds for EOL highlights and Yggdroot plugin configs for BOL highlights {{{
" The following pattern will match trailing whitespace, except when typing at the end of a line.
highlight ExtraWhitespace ctermbg=red guibg=red

augroup whitespace
  :autocmd ColorScheme * highlight ExtraWhitespace ctermbg=red guibg=red

  " If you use this alternate pattern, you may want to consider using the following autocmd to let the highlighting show
  " up as soon as you leave insert mode after entering trailing whitespace:
  " :autocmd InsertLeave * redraw!
  :autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
  :autocmd InsertLeave * match ExtraWhitespace /\s\+$/

  " Uses the detectindent plugin to try to figure out what indent this file should use if a modeline is not available
  if exists(":DetectIndent")
    " When you can't detect how many spaces make up an indent, prefer 4
    let g:detectindent_preferred_indent    = 4
    " When you can't detect spaces vs. tabs, prefer tabs
    let g:detectindent_preferred_expandtab = 0
    :autocmd BufReadPost * :DetectIndent
  endif
augroup END

match ExtraWhitespace /\s\+\%#\@<!$/

" Shows leading space using the indentLine plugin from Yggdroot
let g:indentLine_leadingSpaceEnabled = 1
let g:indentLine_enabled = 0

" }}}

" Python pep8 configurations and pymode and jedi-vim shortcut configurations {{{
" Add ignores for annoying pep8 guidelines
" E501: Lines should be less than 80 characters
" E265: There should be a space between # and comments
let g:pep8_ignore="E501,E265"
let g:pymode_lint_ignore="E501,E265"

" Overwrite pymode's run and doc key binding with my own for relative line numbers
let g:pymode_run_bind = "<C-S-e>"
let g:pymode_doc_bind = "<C-S-d>"

" Overwrite jedi-vim shortcuts
let g:jedi#goto_command = "<C-j>d"
let g:jedi#goto_assignments_command = "<C-j>g"
let g:jedi#goto_definitions_command = ""
let g:jedi#documentation_command = "<C-j>k"
let g:jedi#usages_command = "<C-j>n"
let g:jedi#completions_command = "<C-Space>"
let g:jedi#rename_command = "<C-j>r"

" }}}

" Syntastic specific configurations {{{

" Don't run syntastic check on open
let g:syntastic_check_on_open = 0
" Don't run syntastic check when we're just going to close the window anyway
let g:syntastic_check_on_wq        = 0
" Aggregate errors from multiple checkers instead of stopping
let g:syntastic_aggregate_errors   = 1
" Disable python checkers since we have pymode for that anyway
let g:syntastic_python_checkers    = []
let g:syntastic_python_python_exec = '/bin/true'
" Have syntastic user better symbols for marking errors and warnings
let g:syntastic_error_symbol = "✗"
let g:syntastic_warning_symbol = "⚠"

" }}}

" Use multiple presses of v to expand and ctrl-v to shrink regions {{{
" Actual mappings down in the binding section, see: expand_region_
" Default settings. (NOTE: Remove comments in dictionary before sourcing)
let g:expand_region_text_objects = {
    \ 'iw'  :0,
    \ 'iW'  :0,
    \ 'i"'  :0,
    \ '^o$' :0,
    \ '0o$' :0,
    \ 'i''' :0,
    \ 'i]'  :1,
    \ 'ib'  :1,
    \ 'iB'  :1,
    \ 'il'  :0,
    \ 'ip'  :0,
    \ 'ie'  :0,
    \ }
" }}}

" Persistent undo settings (allows you to get undo back even after closing a file) {{{

if has("persistent_undo")
  let myUndoDir = expand('$HOME/.vim/undodir/')
  call system('mkdir ' . myUndoDir)
  let &undodir = myUndoDir
  set undofile
endif

" }}}

" My functions (toggle solarized background, etc) {{{

" !help! Custom Functions [[[

" !help! RestoreRegister: Prevent replacing copy buffer on visual paste (preserve previous copy item on visual paste)
" hint: makes it so that vp doesn't replace paste buffer
function! RestoreRegister()
  let @" = s:restore_reg
  return ''
endfunction
function! s:Repl()
  let s:restore_reg = @"
  return "p@=RestoreRegister()\<cr>"
endfunction

" !help! MyTogBG: Toggles the background and colorscheme on and off (this helps screens with bad color or copy/paste)
function! MyTogBG()
  redir => s:curr_background
    silent execute "colorscheme"
  redir END
  let s:curr_background = substitute(s:curr_background, '\n', '', '')
  let &background = ( &background == "dark"? "" : "dark" )
  if s:curr_background =~? ".*default.*"
    exe "colorscheme " . s:background
  else
    exe "colorscheme default"
  endif
  let s:background = s:curr_background
endfunction

" !help! MyTogTW: Toggles the textwidth ruler on the right (useful when you don't want autowrap or copy/paste operations)
function! MyTogTW()
  if &tw
    let s:txtwid = &textwidth
    let s:wrapmarg  = &wrapmargin
    let &textwidth  = 0
    let &wrapmargin = 0
  else
    let &textwidth = s:txtwid
    let &wrapmargin = s:wrapmarg
  endif
endfunction

" !help! ToggleCopyable: Toggles all of the above, plus some extra to allow for select based copy/paste operations)
function! ToggleCopyable()
  call MyTogBG()
  set list!
  set number!
  if exists(":LeadingSpaceToggle")
    exe "LeadingSpaceToggle"
  endif
  call MyTogTW()
  if exists(":SyntasticToggleMode")
    exe "SyntasticToggleMode"
  endif
  if exists(":GitGutterToggle")
    exe "GitGutterToggle"
  endif
endfunction

" !help! MyGrepCommand: Automatically opening the quickfix pane (handles MiniBufExplorer)
function! MyGrepCommand(...)
  " This actually runs ag because of the ackprg setting above
  exe "silent Ack " . join(a:000, " ")
  if exists(":MBEClose")
    exe "MBEClose"
  endif
  copen
  exe "redraw!"
  if exists(":MBEOpen")
    exe "MBEOpen"
  endif
endfunction

" !help! MyErrorsCommand: Shows and hides errors and focuses the error list (handles MiniBufExplorer)
function! MyErrorsCommand()
  if exists(":MBEClose")
    exe "MBEClose"
  endif
  if exists(":Errors")
    exe "Errors"
  endif
  exe "redraw!"
  if exists(":MBEOpen")
    exe "MBEOpen"
  endif
  if ! empty(getloclist(0))
    exe "wincmd j"
  endif
endfunction

" !help! ExportKeys: Export current key bindings to a vertical split scratch buffer
function! ExportKeys()
  redir! => l:mappings
    silent exe "map"
  redir END
  exe "vnew | put =l:mappings"
  setlocal buftype=nofile bufhidden=hide noswapfile
  let b:scratch = 1
  1
  " This could be d 4 but then VIM stops to tell me that 4 lines were removed and X number of lines were added
  d
  d
  d
  d
endfunction

" !help! VSplitCurrentBuffer: Split the current buffer and rotate main screen to previous buffer
function! VSplitCurrentBuffer()
  vs
  wincmd h
  bp
endfunction

" !help! s:RunShellCommand: Function to paste the output of a command inside a scratch buffer
function! s:RunShellCommand(cmdline)
  let isfirst = 1
  let words = []
  for word in split(a:cmdline)
    if isfirst
      let isfirst = 0  " don't change first word (shell command)
    else
      if word[0] =~ '\v[%#<]'
        let word = expand(word)
      endif
      let word = shellescape(word, 1)
    endif
    call add(words, word)
  endfor
  let expanded_cmdline = join(words)
  botright vnew
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  silent execute '$read !'. expanded_cmdline
  let b:scratch = 1
  1
  d
endfunction

" !help! ShowVimCustomizations: Show VIM customizations
function! ShowVimCustomizations()
  call s:RunShellCommand('extract_vim_help')
  set modeline | doautocmd BufRead
endfunction

" !help! ]]]
" }}}

" Custom commands {{{

" !help! Custom Commands [[[
" !help! ToggleBG: Calls function MyTogBG() to toggle the background color
command! ToggleBG :call MyTogBG()
" !help! toggleTextWidth: Calls function MyTogTW() to toggle the text width limitations
command! ToggleTextWidth :call MyTogTW()
" !help! ToggleCopyable: Calls function ToggleCopyable() to toggle copy mode of text
command! ToggleCopyable :call ToggleCopyable()
" !help! AG: Calls function MyGrepCommand to use AG to grep through stuff
command! -nargs=* AG :call MyGrepCommand(<f-args>)
" !help! Shell: Calls s:RunShellCommand to show command output in a vertical split
command! -complete=shellcmd -nargs=+ Shell call s:RunShellCommand(<q-args>)
" !help! ]]]

" }}}

" Remapping keys using combos and leaders {{{

" Reminder of what stuff means:
" (remap is the default, noremap means that the binding is not recursive, meaning that whatever the value of the binding
" is, it takes that value regardless of other surrounding bindings)
"
" :map  - Normal, Visual, Select, Operator-pending
" :nmap - Normal
" :vmap - Visual and Select
" :smap - Select
" :xmap - Visual
" :omap - Operator-pending
" :map! - Insert and Command-line
" :imap - Insert
" :lmap - Insert, Command-line, Lang-Arg
" :cmap - Command-line

" !help! Key Bindings [[[

" !help! Command Bindings [[[

" !help!  w!!: Allow saving of files as sudo when we forgot to start vim using sudo
cmap w!! w !sudo tee > /dev/null %
" !help! ]]]

" !help! Visual Bindings [[[
" !help! v: Expand selection with multiple presses of v
vmap v <Plug>(expand_region_expand)
" !help! <CTRL-v>: Shrink Selection with multiple presses of CTRL-v
vmap <C-v> <Plug>(expand_region_shrink)
" !help! p: Change visual paste to use the Repl() function described in "Prevent replacing copy buffer..."
vmap <silent> <expr> p <sid>Repl()
" !help! y: Jump to the end of the text you just pasted
vnoremap <silent> y y`]
" !help! p: Jump to the end of the text you just pasted
vnoremap <silent> p p`]
" !help! <Leader-d>: Delete item to the blackhole register (meaning don't overwrite the current buffer)
vnoremap <Leader>d "_d
" !help! ]]]

" !help! Normal Bindings [[[
" !help! p: Jump to the end of the text you just pasted
nnoremap <silent> p p`]
" !help! <Leader-dd>: Delete line to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <Leader>dd "_dd
" !help! <Leader-d>: Delete item to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <Leader>d "_d
" !help! <Leader-x>: Delete character to the blackhole register (meaning don't overwrite the current buffer)
nnoremap <Leader>x "_x
" !help! ]]]

" !help! Insert Bindings [[[
" !help! jj: When hit in quick succession same as escape
imap jj <Esc>
" !help! JJ: When hit in quick succession same as escape
imap JJ <Esc>
" !help! ]]]

" !help! Map Bindings [[[
" !help! gV: Quickly select the text you just pasted
noremap gV `[v`]

" Add control based navigation to insert mode
" !help! <CTRL-g>: Move right one word in any mode
map <C-G> <C-Right>
map! <C-G> <C-Right>
" !help! <CTRL-f>: Move left one word in any mode
map <C-F> <C-Left>
map! <C-F> <C-Left>
" !help! <CTRL-j>: Move to the beginning of the line in any mode
map <C-J> ^
map! <C-J> <Home>
" !help! <CTRL-k>: Move to the end of the line in any mode
map <C-K> $
map! <C-K> <End>

" !help! <CTRL-n>: Go to the previous error location
map <C-n> :lprev<CR>
" !help! <CTRL-m>:Go to the next error location
map <C-m> :lnext<CR>

" Set tab merge alias to vertically split current tab and the tab to the right (or barring that, to the left)
" To put them back to tabs afterward, type CTRL+w, SHIFT+t
" !help! <CTRL-t>: Vertically split the current tab with the one to the right (CTRL+w, SHIFT+t to put it back)
map <C-t> <esc>:Tabmerge right<CR>

" Remap next and previous tab to Ctrl-PgDn and Ctrl-PgUp
" !help! <ALT-h>: Go to previous tab
map <Esc>h :tabp<CR>
" !help! <ALT-l>: Go to next tab
map <Esc>l :tabn<CR>
" !help! <ALT-j>: Go to next buffer
map <Esc>j :bn<CR>
" !help! <ALT-k>: Go to previous buffer
map <Esc>k :bp<CR>

" !help! <leader p>: Toggle paste mode
map <Leader>p :set paste!<CR>
" !help! <leader po>: Paste a partial yank on the line below
map <leader>po :pu<CR>
" !help! <leader pO>: Paste a partial yank on the line above
map <leader>pO :pu!<CR>
" !help! <leader y>: Leader mapping to allow for copying from vim
map <Leader>y :ToggleCopyable<CR>
" !help! <leader w>: Toggle text width on and off
map <Leader>w :ToggleTextWidth<CR>
" !help! <leader l>: Toggle showing certain whitespace characters
map <Leader>l :set list!<CR>:LeadingSpaceToggle<CR>
" !help! <leader n>: Toggle show number
map <Leader>n :set number!<CR>
" !help! <leader r>: Toggle relative line numbering
map <Leader>r :set relativenumber!<CR>
" !help! <leader e>: Shows syntastic errors location window in a way that won't affect MiniBufExplorer
map <Leader>e :call MyErrorsCommand()<CR>
" !help! <leader c>: Close the quickfix window (for things like pylint)
map <Leader>c :lclose<CR>
" !help! <leader csd>: Reset the color scheme to the default (in cases with unconfigured terminals)
map <Leader>csd :ToggleBG<CR>
" !help! <leader t>: Map nerdtree to leader+t
map <Leader>t :NERDTreeToggle<CR>
" !help! <leader k>: Search current buffer for item under the current cursor
map <leader>k :AG <cword> %<CR>
" !help! <leader K>: Search the entire working directory for the item under the cursor
map <leader>K :AG <cword><CR>
" !help! <leader u>: Toggle undo tree and then focus the original vim pane again with leader-u
map <leader>u :UndotreeToggle<cr><C-w>l
" !help! <leader s>: Force a Synstastic check
map <leader>s :SyntasticCheck<CR>
" !help! <leader j>: Re-format a JSON document, this allows you to write compactly, but read "prettily"
map <leader>j :%!python -m json.tool<CR>
" !help! <leader map>: Dump all of the current keys bindings/mappings to a file and open it
map <leader>map :call ExportKeys()<CR>
" !help! <leader vs>: Split the current buffer to the other vertical
map <leader>vs :call VSplitCurrentBuffer()<CR>
" !help! <leader vc>: Open my vim customizations to a vertical split
map <leader>vc :call ShowVimCustomizations()<CR>
" !help! ]]]
" !help! ]]]

" }}}

" vim: fdm=marker ts=2 et
